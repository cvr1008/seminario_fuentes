data.frame(Country = x$Country,
DDD_per_1000_inhabitants_per_day = as.numeric(x$`DDD per 1000 inhabitants per day`))
}))
# Usar la función 'cambio_nombre_codigo' para convertir nombres de países en códigos
DDD_Europa_df <- cambio_nombre_codigo(DDD_Europa_df, "Country")
# Añadir columna para calcular DDD por cada 100 habitantes y eliminar la columna original
DDD_Europa_df <- DDD_Europa_df %>%
mutate(DDD_per_100_inhabitants_per_day = DDD_per_1000_inhabitants_per_day / 10) %>%
select(-DDD_per_1000_inhabitants_per_day)
# Visualización: Crear un gráfico de barras con ggplot2
grafico_DDD <- ggplot(DDD_Europa_df, aes(x = reorder(Country, -DDD_per_100_inhabitants_per_day),
y = DDD_per_100_inhabitants_per_day)) +
geom_bar(stat = "identity", fill = "turquoise") +
labs(title = "DDD por 100 habitantes por día en Europa",
x = "País",
y = "DDD por 100 habitantes por día") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Mostrar el gráfico
grafico_DDD
library(tidyverse)
library(rjson)
library(dplyr)
library(tidyr)
library(ggplot2)
DDD_Europa_Json <- fromJSON(file = "INPUT/DATA/DDD_1000_habitantes_paises.JSON")
DDD_Europa_Json
# --------------------
DDD_Europa_df <- do.call(rbind, lapply(DDD_Europa_Json, function(x) {
data.frame(Country = x$Country,
DDD_per_1000_inhabitants_per_day = as.numeric(x$`DDD per 1000 inhabitants per day`))
}))
# lapply: Aplica una función a cada elemento de una lista y devuelve una lista con los resultados
# function(x): Define una función anónima que será aplicada a cada elemento x de la lista DDD_Europa_Json.
# x$Country: Extrae el campo Country del elemento x.
# x$'DDD per 1000 inhabitants per day': Extrae el campo DDD per 1000 inhabitants per day de x y lo convierte en numérico con as.numeric.
# data.frame(...): Crea un dataframe con dos columnas
# Usar la función 'cambio_nombre_codigo' para convertir nombres de países en códigos
DDD_Europa_df <- cambio_nombre_codigo(DDD_Europa_df, "Country")
# Añadir columna para calcular DDD por cada 100 habitantes y eliminar la columna original
DDD_Europa_df <- DDD_Europa_df %>%
mutate(DDD_per_100_inhabitants_per_day = DDD_per_1000_inhabitants_per_day / 10) %>%
select(-DDD_per_1000_inhabitants_per_day)
# al tratarse del número de dosis estándar consumidas diariamente por cada 1000 personas, se divide entre 10 para
# que sea número de dosis diarias por cada 100 habitantes.
# resumen: el x% de la población de cada país consume antibiótico de forma diaria en el sector
# hospitalario y comunitario.
grafico_DDD <- ggplot(DDD_Europa_df, aes(x = reorder(Country, -DDD_per_100_inhabitants_per_day),
y = DDD_per_100_inhabitants_per_day)) +
geom_bar(stat = "identity", fill = "turquoise") +
labs(title = "DDD por 100 habitantes por día en Europa",
x = "País",
y = "DDD por 100 habitantes por día") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
grafico_DDD
library(tidyverse)
library(rjson)
library(dplyr)
library(tidyr)
library(ggplot2)
DDD_Europa_Json <- fromJSON(file = "INPUT/DATA/DDD_1000_habitantes_paises.JSON")
DDD_Europa_df <- do.call(rbind, lapply(DDD_Europa_Json, function(x) {
data.frame(Country = x$Country,
DDD_per_1000_inhabitants_per_day = as.numeric(x$`DDD per 1000 inhabitants per day`))
}))
# lapply: Aplica una función a cada elemento de una lista y devuelve una lista con los resultados
# function(x): Define una función anónima que será aplicada a cada elemento x de la lista DDD_Europa_Json.
# x$Country: Extrae el campo Country del elemento x.
# x$'DDD per 1000 inhabitants per day': Extrae el campo DDD per 1000 inhabitants per day de x y lo convierte en numérico con as.numeric.
# data.frame(...): Crea un dataframe con dos columnas
# Usar la función 'cambio_nombre_codigo' para convertir nombres de países en códigos
DDD_Europa_df <- cambio_nombre_codigo(DDD_Europa_df, "Country")
# Añadir columna para calcular DDD por cada 100 habitantes y eliminar la columna original
DDD_Europa_df <- DDD_Europa_df %>%
mutate(DDD_per_100_inhabitants_per_day = DDD_per_1000_inhabitants_per_day / 10) %>%
select(-DDD_per_1000_inhabitants_per_day)
# al tratarse del número de dosis estándar consumidas diariamente por cada 1000 personas, se divide entre 10 para
# que sea número de dosis diarias por cada 100 habitantes.
# resumen: el x% de la población de cada país consume antibiótico de forma diaria en el sector
# hospitalario y comunitario.
grafico_DDD <- ggplot(DDD_Europa_df, aes(x = reorder(Country, -DDD_per_1000_inhabitants_per_day),
y = DDD_per_1000_inhabitants_per_day)) +
geom_bar(stat = "identity", fill = "turquoise") +
labs(title = "DDD por 1000 habitantes por día en Europa",
x = "País",
y = "DDD por 1000 habitantes por día") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
grafico_DDD
grafico_DDD <- ggplot(DDD_Europa_df, aes(x = reorder(Country, -DDD_per_100_inhabitants_per_day),
y = DDD_per_100_inhabitants_per_day)) +
geom_bar(stat = "identity", fill = "turquoise") +
labs(title = "DDD por 100 habitantes por día en Europa",
x = "País",
y = "DDD por 100 habitantes por día") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
grafico_DDD
library(tidyverse)
library(rjson)
library(dplyr)
library(tidyr)
library(ggplot2)
DDD_Europa_Json <- fromJSON(file = "INPUT/DATA/DDD_1000_habitantes_paises.JSON")
DDD_Europa_df <- do.call(rbind, lapply(DDD_Europa_Json, function(x) {
data.frame(Country = x$Country,
DDD_per_1000_inhabitants_per_day = as.numeric(x$`DDD per 1000 inhabitants per day`))
}))
# lapply: Aplica una función a cada elemento de una lista y devuelve una lista con los resultados
# function(x): Define una función anónima que será aplicada a cada elemento x de la lista DDD_Europa_Json.
# x$Country: Extrae el campo Country del elemento x.
# x$'DDD per 1000 inhabitants per day': Extrae el campo DDD per 1000 inhabitants per day de x y lo convierte en numérico con as.numeric.
# data.frame(...): Crea un dataframe con dos columnas
# Usar la función 'cambio_nombre_codigo' para convertir nombres de países en códigos
DDD_Europa_df <- cambio_nombre_codigo(DDD_Europa_df, "Country")
# Añadir columna para calcular DDD por cada 100 habitantes y eliminar la columna original
DDD_Europa_df <- DDD_Europa_df %>%
dplyr::mutate(DDD_per_100_inhabitants_per_day = DDD_per_1000_inhabitants_per_day / 10) %>%
select(-DDD_per_1000_inhabitants_per_day)
library(readr)
library(dplyr)
library(ggplot2)
#--------------------------------
# "INPUT/DATA/datos_pib.tsv"
pibPP <- read_table("INPUT/DATA/datos_pib.tsv")
str(pibPP)
# Cambio de nombre columna
colnames(pibPP)[1] <- "pais"
# Nos quedamos con las últimas letras
pibPP$pais <- substr(pibPP$pais, nchar(pibPP$pais) - 1, nchar(pibPP$pais))
lista_pais <- list("BE", "BG", "CZ", "DK", "DE", "EE", "IE", "EL", "ES", "FR", "HR", "IT", "CY", "LV", "LT", "LU", "HU", "MT", "NL",
"AT", "PL", "PT", "RO", "SI", "SK", "FI", "SE")
# nos quedamos solo con los países de la UE
pib <- pibPP %>% filter(pais %in% unlist(lista_pais))
# quitar la columna nula
pib <- pib[, colSums(is.na(pib)) < nrow(pib)]
pib
pib_2022 <- pib %>% select(pais, `2022`)
# ggplot del pib en el 2022 (primero lo ponemos en descendente)
pib_2022_desc <- pib_2022 %>% arrange(desc(`2022`))
# sustituir las etiquetas de los países
pib_2022_desc_gr <- pib_2022_desc %>%
mutate(pais = case_when(
pais == "SK" ~ "Eslovaquia",
pais == "SI" ~ "Slovenia",
pais == "EE" ~ "Estonia",
pais == "MT" ~ "Malta",
pais == "LV" ~ "Latvia",
pais == "HR" ~ "Croatia",
pais == "EL" ~ "Greece",
pais == "BG" ~ "Bulgaria",
TRUE ~ pais # Mantiene los nombres que no están en la lista
))
# Crear el gráfico de barras
grafico_pib <- ggplot(pib_2022_desc, aes(x = reorder(pais, -`2022`), y = `2022`)) +
geom_bar(stat = "identity", fill = "gold") +
labs(x = "País", y = "Valor en 2022", title = "PIB por País en 2022") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) # Rotar etiquetas para mejor legibilidad
grafico_pib
library(readr)
library(dplyr)
library(ggplot2)
#--------------------------------
# "INPUT/DATA/datos_pib.tsv"
pibPP <- read_table("INPUT/DATA/datos_pib.tsv")
# Cambio de nombre columna
colnames(pibPP)[1] <- "pais"
# Nos quedamos con las últimas letras
pibPP$pais <- substr(pibPP$pais, nchar(pibPP$pais) - 1, nchar(pibPP$pais))
lista_pais <- list("BE", "BG", "CZ", "DK", "DE", "EE", "IE", "EL", "ES", "FR", "HR", "IT", "CY", "LV", "LT", "LU", "HU", "MT", "NL",
"AT", "PL", "PT", "RO", "SI", "SK", "FI", "SE")
# nos quedamos solo con los países de la UE
# Filtrar los datos, quitar columnas nulas y seleccionar las columnas necesarias en una tubería
pib_2022_desc <- pibPP %>%
filter(pais %in% unlist(lista_pais)) %>%  # Filtrar por los países en 'lista_pais'
select(where(~ sum(is.na(.)) < n())) %>% # Eliminar columnas con todos los valores nulos
select(pais, `2022`) %>%                 # Seleccionar las columnas 'pais' y '2022'
arrange(desc(`2022`))                    # Ordenar por el PIB del 2022 en orden descendente
# Filtrar los datos, quitar columnas nulas y seleccionar las columnas necesarias en una tubería
pib_2022_desc <- pibPP %>%
dplyr::filter(pais %in% unlist(lista_pais)) %>%  # Filtrar por los países en 'lista_pais'
dplyr::select(where(~ sum(is.na(.)) < n())) %>% # Eliminar columnas con todos los valores nulos
dplyr::select(pais, `2022`) %>%                 # Seleccionar las columnas 'pais' y '2022'
arrange(desc(`2022`))                    # Ordenar por el PIB del 2022 en orden descendente
# Filtrar los datos, quitar columnas nulas y seleccionar las columnas necesarias en una tubería
pib_2022_desc <- pibPP %>%
dplyr::filter(pais %in% unlist(lista_pais)) %>%  # Filtrar por los países en 'lista_pais'
dplyr::select(where(~ sum(is.na(.)) < nrow(.))) %>%# Eliminar columnas con todos los valores nulos
dplyr::select(pais, `2022`) %>%                 # Seleccionar las columnas 'pais' y '2022'
arrange(desc(`2022`))                    # Ordenar por el PIB del 2022 en orden descendente
# Filtrar los datos, quitar columnas nulas y seleccionar las columnas necesarias en una tubería
pib_2022_desc <- pibPP %>%
dplyr::filter(pais %in% unlist(lista_pais)) %>%  # Filtrar por los países en 'lista_pais'
dplyr::select(where(~ all(!is.na(.)))) %>% # Eliminar columnas con todos los valores nulos
dplyr::select(pais, `2022`) %>%                 # Seleccionar las columnas 'pais' y '2022'
arrange(desc(`2022`))                    # Ordenar por el PIB del 2022 en orden descendente
# Crear el gráfico de barras
grafico_pib <- ggplot(pib_2022_desc, aes(x = reorder(pais, -`2022`), y = `2022`)) +
geom_bar(stat = "identity", fill = "gold") +
labs(x = "País", y = "Valor en 2022", title = "PIB por País en 2022") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) # Rotar etiquetas para mejor legibilidad
# Crear el gráfico de barras
grafico_pib <- ggplot(pib_2022_desc, aes(x = reorder(pais, -`2022`), y = `2022`)) +
geom_bar(stat = "identity", fill = "gold") +
labs(x = "País", y = "Valor en 2022", title = "PIB por País en 2022") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) # Rotar etiquetas para mejor legibilidad
library(readr)
library(dplyr)
library(ggplot2)
#--------------------------------
# "INPUT/DATA/datos_pib.tsv"
pibPP <- read_table("INPUT/DATA/datos_pib.tsv")
# Cambio de nombre columna
colnames(pibPP)[1] <- "pais"
# Nos quedamos con las últimas letras
pibPP$pais <- substr(pibPP$pais, nchar(pibPP$pais) - 1, nchar(pibPP$pais))
lista_pais <- list("BE", "BG", "CZ", "DK", "DE", "EE", "IE", "EL", "ES", "FR", "HR", "IT", "CY", "LV", "LT", "LU", "HU", "MT", "NL",
"AT", "PL", "PT", "RO", "SI", "SK", "FI", "SE")
# nos quedamos solo con los países de la UE
# Filtrar los datos, quitar columnas nulas y seleccionar las columnas necesarias en una tubería
pib_2022_desc <- pibPP %>%
dplyr::filter(pais %in% unlist(lista_pais)) %>%  # Filtrar por los países en 'lista_pais'
dplyr::select(where(~ all(!is.na(.)))) %>% # Eliminar columnas con todos los valores nulos
dplyr::select(pais, `2022`) %>%                 # Seleccionar las columnas 'pais' y '2022'
arrange(desc(`2022`))                    # Ordenar por el PIB del 2022 en orden descendente
# Crear el gráfico de barras
grafico_pib <- ggplot(pib_2022_desc, aes(x = reorder(pais, -`2022`), y = `2022`)) +
geom_bar(stat = "identity", fill = "gold") +
labs(x = "País", y = "Valor en 2022", title = "PIB por País en 2022") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) # Rotar etiquetas para mejor legibilidad
grafico_pib
pib <- read_table("INPUT/DATA/datos_pib.tsv")
# Cambio de nombre columna
colnames(pib)[1] <- "pais"
# Nos quedamos con las últimas letras
pib$pais <- substr(pibPP$pais, nchar(pibPP$pais) - 1, nchar(pib$pais))
lista_pais <- list("BE", "BG", "CZ", "DK", "DE", "EE", "IE", "EL", "ES", "FR", "HR", "IT", "CY", "LV", "LT", "LU", "HU", "MT", "NL",
"AT", "PL", "PT", "RO", "SI", "SK", "FI", "SE")
# nos quedamos solo con los países de la UE
# Filtrar los datos, quitar columnas nulas y seleccionar las columnas necesarias en una tubería
pib_2022_desc <- pib %>%
dplyr::filter(pais %in% unlist(lista_pais)) %>%  # Filtrar por los países en 'lista_pais'
dplyr::select(where(~ all(!is.na(.)))) %>% # Eliminar columnas con todos los valores nulos
dplyr::select(pais, `2022`) %>%                 # Seleccionar las columnas 'pais' y '2022'
arrange(desc(`2022`))                    # Ordenar por el PIB del 2022 en orden descendente
grafico_pib <- ggplot(pib_2022_desc, aes(x = reorder(pais, -`2022`), y = `2022`)) +
geom_bar(stat = "identity", fill = "gold") +
labs(x = "País", y = "Valor en 2022", title = "PIB por País en 2022") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) # Rotar etiquetas para mejor legibilidad
grafico_pib
pib <- read_table("INPUT/DATA/datos_pib.tsv")
# Cambio de nombre columna
colnames(pib)[1] <- "pais"
# Nos quedamos con las últimas letras
pib$pais <- substr(pibPP$pais, nchar(pibPP$pais) - 1, nchar(pib$pais))
pib <- read_table("INPUT/DATA/datos_pib.tsv")
# Cambio de nombre columna
colnames(pib)[1] <- "pais"
# Nos quedamos con las últimas letras
pib$pais <- substr(pib$pais, nchar(pib$pais) - 1, nchar(pib$pais))
lista_pais <- list("BE", "BG", "CZ", "DK", "DE", "EE", "IE", "EL", "ES", "FR", "HR", "IT", "CY", "LV", "LT", "LU", "HU", "MT", "NL",
"AT", "PL", "PT", "RO", "SI", "SK", "FI", "SE")
# nos quedamos solo con los países de la UE
# Filtrar los datos, quitar columnas nulas y seleccionar las columnas necesarias en una tubería
pib_2022_desc <- pib %>%
dplyr::filter(pais %in% unlist(lista_pais)) %>%  # Filtrar por los países en 'lista_pais'
dplyr::select(where(~ all(!is.na(.)))) %>% # Eliminar columnas con todos los valores nulos
dplyr::select(pais, `2022`) %>%                 # Seleccionar las columnas 'pais' y '2022'
arrange(desc(`2022`))                    # Ordenar por el PIB del 2022 en orden descendente
grafico_pib <- ggplot(pib_2022_desc, aes(x = reorder(pais, -`2022`), y = `2022`)) +
geom_bar(stat = "identity", fill = "gold") +
labs(x = "País", y = "Valor en 2022", title = "PIB por País en 2022") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) # Rotar etiquetas para mejor legibilidad
grafico_pib
pib <- read_table("INPUT/DATA/datos_pib.tsv")
# Cambio de nombre columna
colnames(pib)[1] <- "pais"
# Nos quedamos con las últimas letras
pib$pais <- substr(pib$pais, nchar(pib$pais) - 1, nchar(pib$pais))
lista_pais <- list("BE", "BG", "CZ", "DK", "DE", "EE", "IE", "EL", "ES", "FR", "HR", "IT", "CY", "LV", "LT", "LU", "HU", "MT", "NL",
"AT", "PL", "PT", "RO", "SI", "SK", "FI", "SE")
# nos quedamos solo con los países de la UE
# Filtrar los datos, quitar columnas nulas y seleccionar las columnas necesarias en una tubería
pib_2022_desc <- pib %>%
dplyr::filter(pais %in% unlist(lista_pais)) %>%  # Filtrar por los países en 'lista_pais'
dplyr::select(where(~ all(!is.na(.)))) %>% # Eliminar columnas con todos los valores nulos
dplyr::select(pais, `2022`) %>%                 # Seleccionar las columnas 'pais' y '2022'
arrange(desc(`2022`))                    # Ordenar por el PIB del 2022 en orden descendente
library(dplyr)
library(rlang)
cambio_nombre_codigo <- function(Tabla, columna) {
# Convertir el nombre de la columna en un símbolo
columna_sym <- ensym(columna)
Tabla %>%
mutate(
!!columna_sym := case_when(
!!columna_sym == "Slovakia" ~ "SK",
!!columna_sym == "Belgium" ~ "BE",
!!columna_sym == "Cyprus" ~ "CY",
!!columna_sym == "Greece" ~ "EL",
!!columna_sym == "Romania" ~ "RO",
!!columna_sym == "Bulgaria" ~ "BG",
!!columna_sym == "France" ~ "FR",
!!columna_sym == "Malta" ~ "MT",
!!columna_sym == "Poland" ~ "PL",
!!columna_sym == "Spain" ~ "ES",
!!columna_sym == "Ireland" ~ "IE",
!!columna_sym == "Italy" ~ "IT",
!!columna_sym == "Luxembourg" ~ "LU",
!!columna_sym == "Portugal" ~ "PT",
!!columna_sym == "Czech Republic" ~ "CZ",
!!columna_sym == "Czechia" ~ "CZ",
!!columna_sym == "Finland" ~ "FI",
!!columna_sym == "Austria" ~ "AT",
!!columna_sym == "Germany" ~ "DE",
!!columna_sym == "Denmark" ~ "DK",
!!columna_sym == "Estonia" ~ "EE",
!!columna_sym == "Hungary" ~ "HU",
!!columna_sym == "Croatia" ~ "HR",
!!columna_sym == "Lithuania" ~ "LT",
!!columna_sym == "Latvia" ~ "LV",
!!columna_sym == "Netherlands" ~ "NL",
!!columna_sym == "Sweden" ~ "SE",
!!columna_sym == "Slovenia" ~ "SI",
TRUE ~ as.character(!!columna_sym) # Mantener valores originales si no coinciden
)
)
}
cambio_codigo_nombre <- function(Tabla, columna) {
# Convertir el nombre de la columna en un símbolo
columna_sym <- ensym(columna)
Tabla %>%
mutate(
!!columna_sym := case_when(
!!columna_sym == "SK" ~ "Slovakia",
!!columna_sym == "BE" ~ "Belgium",
!!columna_sym == "CY" ~ "Cyprus",
!!columna_sym == "EL" ~ "Greece",
!!columna_sym == "RO" ~ "Romania",
!!columna_sym == "BG" ~ "Bulgaria",
!!columna_sym == "FR" ~ "France",
!!columna_sym == "MT" ~ "Malta",
!!columna_sym == "PL" ~ "Poland",
!!columna_sym == "ES" ~ "Spain",
!!columna_sym == "IE" ~ "Ireland",
!!columna_sym == "IT" ~ "Italy",
!!columna_sym == "LU" ~ "Luxembourg",
!!columna_sym == "PT" ~ "Portugal",
!!columna_sym == "CZ" ~ "Czech Republic",
!!columna_sym == "FI" ~ "Finland",
!!columna_sym == "AT" ~ "Austria",
!!columna_sym == "DE" ~ "Germany",
!!columna_sym == "DK" ~ "Denmark",
!!columna_sym == "EE" ~ "Estonia",
!!columna_sym == "HU" ~ "Hungary",
!!columna_sym == "HR" ~ "Croatia",
!!columna_sym == "LT" ~ "Lithuania",
!!columna_sym == "LV" ~ "Latvia",
!!columna_sym == "NL" ~ "Netherlands",
!!columna_sym == "SE" ~ "Sweden",
!!columna_sym == "SI" ~ "Slovenia",
TRUE ~ as.character(!!columna_sym) # Mantener valores originales si no coinciden
)
)
}
library(tidyverse)
library(rjson)
library(dplyr)
library(tidyr)
library(ggplot2)
DDD_Europa_Json <- fromJSON(file = "INPUT/DATA/DDD_1000_habitantes_paises.JSON")
DDD_Europa_df <- do.call(rbind, lapply(DDD_Europa_Json, function(x) {
data.frame(Country = x$Country,
DDD_per_1000_inhabitants_per_day = as.numeric(x$`DDD per 1000 inhabitants per day`))
}))
# lapply: Aplica una función a cada elemento de una lista y devuelve una lista con los resultados
# function(x): Define una función anónima que será aplicada a cada elemento x de la lista DDD_Europa_Json.
# x$Country: Extrae el campo Country del elemento x.
# x$'DDD per 1000 inhabitants per day': Extrae el campo DDD per 1000 inhabitants per day de x y lo convierte en numérico con as.numeric.
# data.frame(...): Crea un dataframe con dos columnas
# Usar la función 'cambio_nombre_codigo' para convertir nombres de países en códigos
DDD_Europa_df <- cambio_nombre_codigo(DDD_Europa_df, "Country")
# Añadir columna para calcular DDD por cada 100 habitantes y eliminar la columna original
DDD_Europa_df <- DDD_Europa_df %>%
dplyr::mutate(DDD_per_100_inhabitants_per_day = DDD_per_1000_inhabitants_per_day / 10) %>%
select(-DDD_per_1000_inhabitants_per_day)
library(tidyverse)
library(rjson)
library(dplyr)
library(tidyr)
library(ggplot2)
DDD_Europa_Json <- fromJSON(file = "INPUT/DATA/DDD_1000_habitantes_paises.JSON")
DDD_Europa_df <- do.call(rbind, lapply(DDD_Europa_Json, function(x) {
data.frame(Country = x$Country,
DDD_per_1000_inhabitants_per_day = as.numeric(x$`DDD per 1000 inhabitants per day`))
}))
# lapply: Aplica una función a cada elemento de una lista y devuelve una lista con los resultados
# function(x): Define una función anónima que será aplicada a cada elemento x de la lista DDD_Europa_Json.
# x$Country: Extrae el campo Country del elemento x.
# x$'DDD per 1000 inhabitants per day': Extrae el campo DDD per 1000 inhabitants per day de x y lo convierte en numérico con as.numeric.
# data.frame(...): Crea un dataframe con dos columnas
# Usar la función 'cambio_nombre_codigo' para convertir nombres de países en códigos
DDD_Europa_df <- cambio_nombre_codigo(DDD_Europa_df, "Country")
library(dplyr)
library(rlang)
cambio_nombre_codigo <- function(Tabla, columna) {
# Convertir el nombre de la columna en un símbolo
columna_sym <- ensym(columna)
Tabla %>%
mutate(
!!columna_sym := case_when(
!!columna_sym == "Slovakia" ~ "SK",
!!columna_sym == "Belgium" ~ "BE",
!!columna_sym == "Cyprus" ~ "CY",
!!columna_sym == "Greece" ~ "EL",
!!columna_sym == "Romania" ~ "RO",
!!columna_sym == "Bulgaria" ~ "BG",
!!columna_sym == "France" ~ "FR",
!!columna_sym == "Malta" ~ "MT",
!!columna_sym == "Poland" ~ "PL",
!!columna_sym == "Spain" ~ "ES",
!!columna_sym == "Ireland" ~ "IE",
!!columna_sym == "Italy" ~ "IT",
!!columna_sym == "Luxembourg" ~ "LU",
!!columna_sym == "Portugal" ~ "PT",
!!columna_sym == "Czech Republic" ~ "CZ",
!!columna_sym == "Czechia" ~ "CZ",
!!columna_sym == "Finland" ~ "FI",
!!columna_sym == "Austria" ~ "AT",
!!columna_sym == "Germany" ~ "DE",
!!columna_sym == "Denmark" ~ "DK",
!!columna_sym == "Estonia" ~ "EE",
!!columna_sym == "Hungary" ~ "HU",
!!columna_sym == "Croatia" ~ "HR",
!!columna_sym == "Lithuania" ~ "LT",
!!columna_sym == "Latvia" ~ "LV",
!!columna_sym == "Netherlands" ~ "NL",
!!columna_sym == "Sweden" ~ "SE",
!!columna_sym == "Slovenia" ~ "SI",
TRUE ~ as.character(!!columna_sym) # Mantener valores originales si no coinciden
)
)
}
cambio_codigo_nombre <- function(Tabla, columna) {
# Convertir el nombre de la columna en un símbolo
columna_sym <- ensym(columna)
Tabla %>%
mutate(
!!columna_sym := case_when(
!!columna_sym == "SK" ~ "Slovakia",
!!columna_sym == "BE" ~ "Belgium",
!!columna_sym == "CY" ~ "Cyprus",
!!columna_sym == "EL" ~ "Greece",
!!columna_sym == "RO" ~ "Romania",
!!columna_sym == "BG" ~ "Bulgaria",
!!columna_sym == "FR" ~ "France",
!!columna_sym == "MT" ~ "Malta",
!!columna_sym == "PL" ~ "Poland",
!!columna_sym == "ES" ~ "Spain",
!!columna_sym == "IE" ~ "Ireland",
!!columna_sym == "IT" ~ "Italy",
!!columna_sym == "LU" ~ "Luxembourg",
!!columna_sym == "PT" ~ "Portugal",
!!columna_sym == "CZ" ~ "Czech Republic",
!!columna_sym == "FI" ~ "Finland",
!!columna_sym == "AT" ~ "Austria",
!!columna_sym == "DE" ~ "Germany",
!!columna_sym == "DK" ~ "Denmark",
!!columna_sym == "EE" ~ "Estonia",
!!columna_sym == "HU" ~ "Hungary",
!!columna_sym == "HR" ~ "Croatia",
!!columna_sym == "LT" ~ "Lithuania",
!!columna_sym == "LV" ~ "Latvia",
!!columna_sym == "NL" ~ "Netherlands",
!!columna_sym == "SE" ~ "Sweden",
!!columna_sym == "SI" ~ "Slovenia",
TRUE ~ as.character(!!columna_sym) # Mantener valores originales si no coinciden
)
)
}
library(tidyverse)
library(rjson)
library(dplyr)
library(tidyr)
library(ggplot2)
DDD_Europa_Json <- fromJSON(file = "INPUT/DATA/DDD_1000_habitantes_paises.JSON")
DDD_Europa_df <- do.call(rbind, lapply(DDD_Europa_Json, function(x) {
data.frame(Country = x$Country,
DDD_per_1000_inhabitants_per_day = as.numeric(x$`DDD per 1000 inhabitants per day`))
}))
# lapply: Aplica una función a cada elemento de una lista y devuelve una lista con los resultados
# function(x): Define una función anónima que será aplicada a cada elemento x de la lista DDD_Europa_Json.
# x$Country: Extrae el campo Country del elemento x.
# x$'DDD per 1000 inhabitants per day': Extrae el campo DDD per 1000 inhabitants per day de x y lo convierte en numérico con as.numeric.
# data.frame(...): Crea un dataframe con dos columnas
# Usar la función 'cambio_nombre_codigo' para convertir nombres de países en códigos
DDD_Europa_df <- cambio_nombre_codigo(DDD_Europa_df, "Country")
# Añadir columna para calcular DDD por cada 100 habitantes y eliminar la columna original
DDD_Europa_df <- DDD_Europa_df %>%
dplyr::mutate(DDD_per_100_inhabitants_per_day = DDD_per_1000_inhabitants_per_day / 10) %>%
select(-DDD_per_1000_inhabitants_per_day)
grafico_DDD <- ggplot(DDD_Europa_df, aes(x = reorder(Country, -DDD_per_100_inhabitants_per_day),
y = DDD_per_100_inhabitants_per_day)) +
geom_bar(stat = "identity", fill = "turquoise") +
labs(title = "DDD por 100 habitantes por día en Europa",
x = "País",
y = "DDD por 100 habitantes por día") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
grafico_DDD
