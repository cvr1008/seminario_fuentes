---
title: "seminario_fuentes"
author: "Deyanira y Cristina"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:
## Funcion para sacar los datos JSON
Tenemos la carpeta "Resistencia_Antibioticos_UE" con 27 archivos .jsonld por lo que hemos creado 3 funciones para obtener los datos.

La funcion obtener_nombre obtiene una lista con los nombres de los archivos que contiene la carpeta

La función obtener_archivo carga cada archivo, accede al enlace necesario y descarga la carpeta.zip (con los datos) de cada archivo y las guarda en una carpeta 

La función leer_archivo recorre la carpeta que contiene los archivos.zip los descomprime y carga los datos excel. Hace un dataframe con los datos y los almacena en el global enviroment de cada uno de los paises.
```{r cars}
eval=FALSE
library(httr)
library(tidyverse)
library(jsonlite)
library(readxl)
library(rjson)

obtener_nombre<-function(carpeta){
  archivos <- as.list(list.files(path =carpeta))
  lista_nombres<-list()
  for(i in 1:length(archivos)){
    posicion1<-regexpr("_", archivos[[i]])
    posicion2<-regexpr("\\.", archivos[[i]])
    subcadena<-substr(archivos[[i]], posicion1+1, posicion2-1)
    lista_nombres[[i]]<-subcadena
  }
  
  return(lista_nombres)
  
}


obtener_archivo<-function(direccion){
  lista_paises<-obtener_nombre(direccion)
  lista_enlace<-list()
  direccion_archivos<-list()
  
  for(i in lista_paises){
    cada_pais<-paste0("AMR_",i,".json")
    lista_enlace[i]<-cada_pais
  }
  for(i in lista_enlace){
    
    cada_archivo<-paste0(direccion,"/",i)
    direccion_archivos[i]<-cada_archivo
  }
  
  
  for(i in direccion_archivos){
    pais<-fromJSON(file= i)
    enlace<-pais$links$archive
    respuesta_archivo <- GET(enlace)# Hacer la solicitud HTTP para descargar el archivo
    nombre_archivo<-basename(enlace)#Extrae el nombre del archivo de la URL
    
    if (status_code(respuesta_archivo) == 200) {# Verificar si la solicitud fue exitosa (código 200, código estándar HTTP que significa "OK")
      # Guardar el archivo ZIP localmente en formato binario
      writeBin(content(respuesta_archivo, "raw"), nombre_archivo)
      print("Archivo ZIP descargado correctamente.")
      unzip(nombre_archivo, exdir = "carpeta_destino", overwrite = TRUE)
    } else {
      print(paste("Error al descargar el archivo. Código de respuesta:", status_code(respuesta_archivo)))
    }
    
   
  }
  
}
obtener_archivo("INPUT/DATA/Resistecia_Antibioticos_UE")






leer_archivo <- function(carpeta) {
  carpeta_destino <- carpeta
  archivos_zip <- list.files(carpeta_destino, pattern = "\\.zip$", full.names = TRUE)
  
  # Iterar sobre los archivos .zip y descomprimirlos
  for (archivo in archivos_zip) {
    # Descomprimir el archivo .zip
    archivos_extraidos <- unzip(archivo, exdir = carpeta_destino, overwrite = TRUE)
    print(paste("Descomprimido:", archivo))  # Imprimir cada archivo que se descomprime
    
    # Filtrar el archivo .xlsx entre los extraídos
    archivo_xlsx <- archivos_extraidos[grepl("\\.xlsx$", archivos_extraidos)]#Aquí, grepl() busca archivos cuyos nombres terminen con .xlsx 
    
    # Verificar si hay algún archivo .xlsx descomprimido
    if (length(archivo_xlsx) > 0) {
      # Leer el archivo Excel como dataframe
      datos_xlsx <- read_excel(archivo_xlsx[1])  # Leer el primer archivo .xlsx encontrado
      
      # Asignar el dataframe al Global Environment usando el nombre del archivo como variable
      nombre_variable <- make.names(basename(archivo_xlsx[1]))  # Crear un nombre de variable válido
      assign(nombre_variable, datos_xlsx, envir = .GlobalEnv)  # Asignar el dataframe al Global Environment
      
    } 
  }
}


leer_archivo("carpeta_destino")




```
## Juntar todos los dataframes que tenemos en el enviroment
1. Listar los nombres de todos los dataframes que terminan en ".xlsx" (ajusta si es necesario)
2. Convertir los nombres a una lista de dataframes usando mget()
3. Unir todos los dataframes en uno solo usando bind_rows
```{r}
eval=FALSE

nombres_dataframes <- ls(pattern = "_AMR_PUB\\.xlsx$")


lista_dataframes <- mget(nombres_dataframes)

 
df_combinado <- bind_rows(lista_dataframes, .id = "origen")

```
##Cargamos el globalEnviroment
En el que tenemos guardado todos los dataframe de cada pais resultante de la funcion leer_archivo, y el dataframe df_combinado del codigo anterior
```{r}
load("OUTPUT/paisesUE_datosAMR.RData")
```
##Modificación y obtencion del dataframe con los datos
seleccionamos las columnas que vamos a necesitar y filtramos en la columna de las bacterias solo las patogénicas.

Cambiamos los nombres de las columnas y lo asignamos al dataframe
```{r}

paises_UE_df<-df_combinado%>%
  select(rep_Country_name,rep_Country_code,zoonosis_name,matrix_name,totUnitsTested,totUnitsPositive,sampUnitType_name,sampType_name,MIC_name,CUTOFFVALUE)%>%
  filter(zoonosis_name != "Escherichia coli, non-pathogenic, unspecified")


nuevos_nombres <- c("NombrePais", "Codigo", "zoonosis_name","OrigenMuestra", "TotalMuestras","MuestraPositiva","Tipo_Unidad_Muestra","TipoMuestra","MIC_name","ValorCorte")  # Modifica según el número de columnas

colnames(paises_UE_df) <- nuevos_nombres
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
